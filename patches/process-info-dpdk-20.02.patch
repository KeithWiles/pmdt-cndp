From d86bf348f357c90fdf04edc7d6b983a36afcf0d2 Mon Sep 17 00:00:00 2001
From: Keith Wiles <keith.wiles@intel.com>
Date: Thu, 23 Jan 2020 13:50:50 -0600
Subject: [PATCH] pinfo: adding process info library

The process information library is used to collect metrics from
DPDK and applications. The Process Info design was created by Bruce
Richardson @ intel.

The process information uses a local domain socket to export internal
application metrics using a simple command string with JSON string
being returned.

When an application is built the process info thread is started and
it creates a local domain socket in /var/run/dpdk/rte/process_info.<Pid>

   Note: If using a file-prefix for your application execution then
         'rte' will be replaced with the file prefix string.

For testing a python script called usertools/test_pinfo.py can be used
to access the socket and display metric information in JSON format.

The Process Info design outputs basic JSON formatted strings and does not
parse JSON strings as the command format is a simple string. The command
string is of the format '/<command>,<options>' using the test_pinfo.py script
you can enter '/' command to display all of the current know commands.

The <command> string uses <cmdgroup>:<subcmd> as the format for the string
to allow for adding new command groups and/or extending subcmds for existing
command groups.

e.g.
sudo ./usertools/test_pinfo.py
--> /
{"cmds": ["/","/dpdk:info","/ethdev:list","/ethdev:stats","/ethdev:xstats","/rawdev:list","/rawdev:xstats","/eal:params"]}
-->
--> /ethdev:list
{"ports": [{"port": 0, "duplex": "Full", "state": "UP", "rate": 40000 },{"port": 1, "duplex": "Full", "state": "UP", "rate": 100000 },{"port": 2, "duplex": "Full", "state": "UP", "rate": 40000 },{"port": 3, "duplex": "Full", "state": "UP", "rate": 100000 }], "avail": 4, "total": 4}
--> /ethdev:stats,0
{"portid":0,"ipackets":0,"opackets":0,"ibytes":0,"obytes":0,"imissed":0,"ierrors":0,"oerrors":0,"rx_nombuf":0,"q_ipackets": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"q_opackets": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"q_ibytes": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"q_obytes": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"q_errors": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
--> /eal:params
{"ealargs": ["./app/x86_64-native-linux-gcc/pktgen","-l","2,3-4,5-6,16-17,18-19","-n","4","--proc-type","auto","--log-level","7","--file-prefix","pg","-w","05:00.0,safe-mode-support=1","-w","84:00.0,safe-mode-support=1","-w","03:00.0","-w","81:00.0"],"appargs": ["-v","-T","-P","-j","-m","[3:4].0","-m","[5:6].1","-m","[16:17].2","-m","[18:19].3","-f","themes/black-yellow.theme"]}

The <option> value in the case of /ethdev:stat,<option> is the port number.

Signed-off-by: Keith Wiles <keith.wiles@intel.com>
---
 config/common_linux                           |   1 +
 lib/Makefile                                  |   2 +
 lib/librte_eal/freebsd/eal/eal.c              |  42 +++
 lib/librte_eal/linux/eal/Makefile             |   1 +
 lib/librte_eal/linux/eal/eal.c                |  59 +++
 lib/librte_eal/meson.build                    |   2 +-
 lib/librte_ethdev/Makefile                    |   3 +-
 lib/librte_ethdev/rte_ethdev.c                | 186 ++++++++++
 lib/librte_process_info/Makefile              |  21 ++
 lib/librte_process_info/meson.build           |   9 +
 lib/librte_process_info/process_info.c        | 338 ++++++++++++++++++
 lib/librte_process_info/rte_process_info.h    |  40 +++
 .../rte_process_info_version.map              |   7 +
 lib/librte_rawdev/Makefile                    |   4 +-
 lib/librte_rawdev/meson.build                 |   2 +
 lib/librte_rawdev/rte_rawdev.c                |  89 +++++
 lib/meson.build                               |   3 +-
 meson.build                                   |   1 +
 mk/rte.app.mk                                 |   1 +
 usertools/test_pinfo.py                       |  22 ++
 20 files changed, 829 insertions(+), 4 deletions(-)
 create mode 100644 lib/librte_process_info/Makefile
 create mode 100644 lib/librte_process_info/meson.build
 create mode 100644 lib/librte_process_info/process_info.c
 create mode 100644 lib/librte_process_info/rte_process_info.h
 create mode 100644 lib/librte_process_info/rte_process_info_version.map
 create mode 100755 usertools/test_pinfo.py

diff --git a/config/common_linux b/config/common_linux
index 583efadc7..86c5a1cd6 100644
--- a/config/common_linux
+++ b/config/common_linux
@@ -26,6 +26,7 @@ CONFIG_RTE_LIBRTE_NFP_PMD=y
 CONFIG_RTE_LIBRTE_POWER=y
 CONFIG_RTE_VIRTIO_USER=y
 CONFIG_RTE_PROC_INFO=y
+CONFIG_RTE_LIBRTE_PROCESS_INFO=y

 CONFIG_RTE_LIBRTE_VMBUS=y
 CONFIG_RTE_LIBRTE_NETVSC_PMD=y
diff --git a/lib/Makefile b/lib/Makefile
index 46b91ae1a..e122e54e8 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -18,6 +18,8 @@ DIRS-$(CONFIG_RTE_LIBRTE_MBUF) += librte_mbuf
 DEPDIRS-librte_mbuf := librte_eal librte_mempool
 DIRS-$(CONFIG_RTE_LIBRTE_TIMER) += librte_timer
 DEPDIRS-librte_timer := librte_eal
+DIRS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO) += librte_process_info
+DEPDIRS-librte_process_info := librte_eal
 DIRS-$(CONFIG_RTE_LIBRTE_CFGFILE) += librte_cfgfile
 DEPDIRS-librte_cfgfile := librte_eal
 DIRS-$(CONFIG_RTE_LIBRTE_CMDLINE) += librte_cmdline
diff --git a/lib/librte_eal/freebsd/eal/eal.c b/lib/librte_eal/freebsd/eal/eal.c
index 6ae37e7e6..5645ca42e 100644
--- a/lib/librte_eal/freebsd/eal/eal.c
+++ b/lib/librte_eal/freebsd/eal/eal.c
@@ -90,6 +90,28 @@ static char runtime_dir[PATH_MAX];

 static const char *default_runtime_dir = "/var/run";

+static char **eal_args;
+
+/* callback handler for process_info library to report out EAL flags */
+static int
+handle_eal_params_request(const char *cmd __rte_unused,
+		const char *params __rte_unused,
+		char *buffer, int buf_len)
+{
+	int used = 0;
+	int i = 0;
+
+	if (eal_args == NULL || eal_args[0] == NULL)
+		return -1;
+
+	used = strlcpy(buffer, "[", buf_len);
+	while (eal_args[i] != NULL)
+		used += snprintf(buffer + used, buf_len - used, "\"%s\",",
+				eal_args[i++]);
+	buffer[used - 1] = ']';
+	return used;
+}
+
 int
 eal_create_runtime_dir(void)
 {
@@ -724,6 +746,20 @@ rte_eal_init(int argc, char **argv)

 	eal_reset_internal_config(&internal_config);

+	/* clone argv to report out later */
+	eal_args = calloc(argc + 1, sizeof(*eal_args));
+	if (eal_args != NULL) {
+		for (i = 0; i < argc; i++) {
+			eal_args[i] = strdup(argv[i]);
+			if (strcmp(argv[i], "--") == 0)
+				break;
+		}
+		eal_args[i] = NULL; /* always finish with NULL */
+
+		rte_process_info_register("/eal_params",
+				handle_eal_params_request);
+	}
+
 	/* set log level as early as possible */
 	eal_log_level_parse(argc, argv);

@@ -953,6 +989,12 @@ rte_eal_init(int argc, char **argv)
 		return -1;
 	}

+	const char *error_str;
+	if (rte_process_info_init(rte_eal_get_runtime_dir(), &error_str) != 0) {
+		rte_eal_init_alert(error_str);
+		return -1;
+	}
+
 	eal_mcfg_complete();

 	/* Call each registered callback, if enabled */
diff --git a/lib/librte_eal/linux/eal/Makefile b/lib/librte_eal/linux/eal/Makefile
index e70cf104a..448232d96 100644
--- a/lib/librte_eal/linux/eal/Makefile
+++ b/lib/librte_eal/linux/eal/Makefile
@@ -16,6 +16,7 @@ CFLAGS += -DALLOW_EXPERIMENTAL_API
 CFLAGS += -I$(SRCDIR)/include
 CFLAGS += -I$(RTE_SDK)/lib/librte_eal/common
 CFLAGS += -I$(RTE_SDK)/lib/librte_eal/common/include
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
 CFLAGS += $(WERROR_FLAGS) -O3

 LDLIBS += -ldl
diff --git a/lib/librte_eal/linux/eal/eal.c b/lib/librte_eal/linux/eal/eal.c
index 9530ee55f..1e27d8fab 100644
--- a/lib/librte_eal/linux/eal/eal.c
+++ b/lib/librte_eal/linux/eal/eal.c
@@ -51,6 +51,7 @@
 #include <malloc_heap.h>
 #include <rte_vfio.h>
 #include <rte_option.h>
+#include <rte_process_info.h>

 #include "eal_private.h"
 #include "eal_thread.h"
@@ -104,6 +105,38 @@ static char runtime_dir[PATH_MAX];

 static const char *default_runtime_dir = "/var/run";

+static char **eal_args, **app_args;
+static int eal_argc;
+
+/* callback handler for process_info library to report out EAL flags */
+static int
+handle_eal_params_request(struct pinfo_client *c)
+{
+	char **p;
+	int i;
+
+	if (eal_args == NULL || eal_args[0] == NULL)
+		return -1;
+
+	rte_process_info_append(c, "\"ealargs\": [");
+	for (i = 0, p = eal_args; i < eal_argc; i++, p++) {
+		if (p == app_args)
+			break;
+		rte_process_info_append(c, "\"%s\"%s",
+				*p, ((p + 1) != app_args)? "," : "");
+	}
+	if (app_args != NULL) {
+		rte_process_info_append(c, "],\"appargs\": [");
+		for (p = app_args; i < eal_argc && *p != NULL; i++, p++) {
+			rte_process_info_append(c, "\"%s\"%s",
+					*p, (p[1] != NULL)? "," : "");
+		}
+	}
+	rte_process_info_append(c, "]");
+
+	return c->used;
+}
+
 int
 eal_create_runtime_dir(void)
 {
@@ -988,6 +1021,27 @@ rte_eal_init(int argc, char **argv)

 	eal_reset_internal_config(&internal_config);

+	/* clone argv to report out later */
+	eal_argc = argc;
+	eal_args = calloc(argc + 1, sizeof(*eal_args));
+	app_args = NULL;
+	if (eal_args != NULL) {
+		char **p = eal_args;
+
+		for (i = 0; i < argc; i++) {
+			if (strcmp(argv[i], "--") == 0)
+				app_args = p;
+			else
+				*p++ = strdup(argv[i]);
+		}
+		*p = NULL; /* always finish with NULL */
+		if (app_args == NULL)
+			app_args = p;
+
+		rte_process_info_register("/eal:params",
+				handle_eal_params_request);
+	}
+
 	/* set log level as early as possible */
 	eal_log_level_parse(argc, argv);

@@ -1292,6 +1346,11 @@ rte_eal_init(int argc, char **argv)
 		return -1;
 	}

+	const char *error_str;
+	if (rte_process_info_init(rte_eal_get_runtime_dir(), &error_str) != 0) {
+		rte_eal_init_alert(error_str);
+		return -1;
+	}
 	eal_mcfg_complete();

 	/* Call each registered callback, if enabled */
diff --git a/lib/librte_eal/meson.build b/lib/librte_eal/meson.build
index 4be5118ce..89ee3b6b8 100644
--- a/lib/librte_eal/meson.build
+++ b/lib/librte_eal/meson.build
@@ -13,7 +13,7 @@ dpdk_conf.set('RTE_EXEC_ENV_' + exec_env.to_upper(), 1)
 subdir(exec_env + '/eal')

 allow_experimental_apis = true
-deps += 'kvargs'
+deps += ['kvargs', 'process_info']
 if dpdk_conf.has('RTE_USE_LIBBSD')
 	ext_deps += libbsd
 endif
diff --git a/lib/librte_ethdev/Makefile b/lib/librte_ethdev/Makefile
index b627e4e23..f1a0f0835 100644
--- a/lib/librte_ethdev/Makefile
+++ b/lib/librte_ethdev/Makefile
@@ -11,8 +11,9 @@ LIB = librte_ethdev.a
 CFLAGS += -DALLOW_EXPERIMENTAL_API
 CFLAGS += -O3
 CFLAGS += $(WERROR_FLAGS)
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
 LDLIBS += -lrte_net -lrte_eal -lrte_mempool -lrte_ring
-LDLIBS += -lrte_mbuf -lrte_kvargs -lrte_meter
+LDLIBS += -lrte_mbuf -lrte_kvargs -lrte_meter -lrte_process_info

 EXPORT_MAP := rte_ethdev_version.map

diff --git a/lib/librte_ethdev/rte_ethdev.c b/lib/librte_ethdev/rte_ethdev.c
index 9d62dc436..8dc59270f 100644
--- a/lib/librte_ethdev/rte_ethdev.c
+++ b/lib/librte_ethdev/rte_ethdev.c
@@ -38,6 +38,7 @@
 #include <rte_kvargs.h>
 #include <rte_class.h>
 #include <rte_ether.h>
+#include <rte_process_info.h>

 #include "rte_ethdev.h"
 #include "rte_ethdev_driver.h"
@@ -5191,9 +5192,194 @@ rte_eth_devargs_parse(const char *dargs, struct rte_eth_devargs *eth_da)
 	return result;
 }

+static int
+handle_port_list(struct pinfo_client *c)
+{
+	struct rte_eth_link link;
+	int used = 0;
+	int port_id;
+
+	rte_process_info_append(c, "\"ports\": [");
+	RTE_ETH_FOREACH_DEV(port_id) {
+		rte_eth_link_get_nowait(port_id, &link);
+		rte_process_info_append(c, "{\"port\": %d, \"duplex\": \"%s\", \"state\": \"%s\", \"rate\": %d }%s",
+			port_id,
+			link.link_duplex == ETH_LINK_FULL_DUPLEX? "Full" : "Half",
+			link.link_status == ETH_LINK_UP? "UP" : "DOWN",
+			link.link_speed,
+			((port_id + 1) < rte_eth_dev_count_avail())? "," : "");
+	}
+
+	rte_process_info_append(c, "], \"avail\": %d, \"total\": %d",
+		rte_eth_dev_count_avail(), rte_eth_dev_count_total());
+	return used;
+}
+
+static int
+handle_port_stats(struct pinfo_client *c)
+{
+	struct rte_eth_stats eth_stats;
+	int port_id;
+	int i;
+
+	memset(&eth_stats, 0, sizeof(struct rte_eth_stats));
+
+	if (c->params == NULL)
+		goto error;
+
+	port_id = atoi(c->params);
+
+	if (!rte_eth_dev_is_valid_port(port_id))
+		goto error;
+
+	if (rte_eth_stats_get(port_id, &eth_stats))
+		goto error;
+
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",", "portid", port_id) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ipackets", eth_stats.ipackets) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"opackets", eth_stats.opackets) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ibytes", eth_stats.ibytes) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"obytes", eth_stats.obytes) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"imissed", eth_stats.imissed) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ierrors", eth_stats.ierrors) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"oerrors", eth_stats.oerrors) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"rx_nombuf", eth_stats.rx_nombuf) < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_ipackets\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_ipackets[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_opackets\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_opackets[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_ibytes\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_ibytes[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_obytes\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_obytes[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_errors\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_errors[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "]") < 0)
+		goto error;
+
+	return 0;
+
+error:
+	return -1;
+}
+
+static int
+handle_port_xstats(struct pinfo_client *c)
+{
+	struct rte_eth_xstat *eth_xstats;
+	struct rte_eth_xstat_name *xstat_names;
+	int port_id, num_xstats;
+	int i, ret;
+	int used;
+
+	used = 0;
+	eth_xstats = NULL;
+
+	if (c->params == NULL)
+		goto error;
+
+	port_id = atoi(c->params);
+
+	if (!rte_eth_dev_is_valid_port(port_id))
+		goto error;
+
+	num_xstats = rte_eth_xstats_get(port_id, NULL, 0);
+	if (num_xstats < 0)
+		goto error;
+
+	/* use one malloc for both names and stats */
+	eth_xstats = malloc((sizeof(struct rte_eth_xstat) +
+			sizeof(struct rte_eth_xstat_name)) * num_xstats);
+	if (eth_xstats == NULL)
+		goto error;
+	xstat_names = (void *)&eth_xstats[num_xstats];
+
+	ret = rte_eth_xstats_get_names(port_id, xstat_names, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	ret = rte_eth_xstats_get(port_id, eth_xstats, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++) {
+		if (rte_process_info_append(c, "\"%s\":%"PRIu64"%s",
+				xstat_names[i].name, eth_xstats[i].value,
+				((i + 1) < num_xstats)? "," : "") < 0)
+			goto error;
+	}
+
+	free(eth_xstats);
+	eth_xstats = NULL;
+
+	return used;
+
+error:
+	free(eth_xstats);
+	return -1;
+}
+
 RTE_INIT(ethdev_init_log)
 {
 	rte_eth_dev_logtype = rte_log_register("lib.ethdev");
 	if (rte_eth_dev_logtype >= 0)
 		rte_log_set_level(rte_eth_dev_logtype, RTE_LOG_INFO);
+	rte_process_info_register("/ethdev:list", handle_port_list);
+	rte_process_info_register("/ethdev:stats", handle_port_stats);
+	rte_process_info_register("/ethdev:xstats", handle_port_xstats);
 }
diff --git a/lib/librte_process_info/Makefile b/lib/librte_process_info/Makefile
new file mode 100644
index 000000000..9ade85a86
--- /dev/null
+++ b/lib/librte_process_info/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2010-2014 Intel Corporation
+
+include $(RTE_SDK)/mk/rte.vars.mk
+
+# library name
+LIB = librte_process_info.a
+
+CFLAGS += $(WERROR_FLAGS) -I$(SRCDIR) -O3
+CFLAGS += -DALLOW_EXPERIMENTAL_API
+LDLIBS += -lrte_eal
+
+EXPORT_MAP := rte_process_info_version.map
+
+# all source are stored in SRCS-y
+SRCS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO) := process_info.c
+
+# install includes
+SYMLINK-$(CONFIG_RTE_LIBRTE_PROCESS_INFO)-include := rte_process_info.h
+
+include $(RTE_SDK)/mk/rte.lib.mk
diff --git a/lib/librte_process_info/meson.build b/lib/librte_process_info/meson.build
new file mode 100644
index 000000000..ac4e333f0
--- /dev/null
+++ b/lib/librte_process_info/meson.build
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2018 Intel Corporation
+
+includes = [global_inc]
+includes += include_directories('../librte_eal/common/include/arch/' + arch_subdir)
+
+allow_experimental_apis = true
+sources = files('process_info.c')
+headers = files('rte_process_info.h')
diff --git a/lib/librte_process_info/process_info.c b/lib/librte_process_info/process_info.c
new file mode 100644
index 000000000..9240b4bd4
--- /dev/null
+++ b/lib/librte_process_info/process_info.c
@@ -0,0 +1,338 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2020 Intel Corporation
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <dlfcn.h>
+
+#include <rte_version.h>
+#include <rte_string_fns.h>
+#include <rte_common.h>
+#include <rte_spinlock.h>
+
+#include "rte_process_info.h"
+
+
+static int list_cmd(struct pinfo_client *c);
+static int info_cmd(struct pinfo_client *c);
+
+#define MAX_CMD_LEN	56
+
+struct cmd_callback {
+	char cmd[MAX_CMD_LEN];
+	process_info_cb fn;
+};
+
+static int sock = -1;
+static struct sockaddr_un sun;
+static char process_info_log_error[1024];
+static struct cmd_callback callbacks[PINFO_MAX_CALLBACKS + 1] = {
+		{ .cmd = "/", .fn = list_cmd },
+		{ .cmd = "/dpdk:info", .fn = info_cmd },
+};
+static int num_callbacks = 2;
+static rte_spinlock_t callback_sl = RTE_SPINLOCK_INITIALIZER;
+
+/* we won't link against libbsd, so just always use DPDKs-specific version */
+#ifndef strlcpy
+#define strlcpy rte_strlcpy
+#endif
+#ifndef strlcat
+#define strlcat rte_strlcat
+#endif
+
+/*
+ * find a command in the list of callbacks
+ *
+ * @params cmd
+ *    The command string to search in the callback list case-insenstive
+ * @return
+ *    returns the index of the matching command of -1 if not found
+ */
+static int
+find_command(const char *cmd)
+{
+	int	i = -1;
+
+	if (cmd && cmd[0] == '/') {
+		for(i = 0; i < num_callbacks; i++) {
+			if (strcasecmp(cmd, callbacks[i].cmd) == 0)
+				return i;
+		}
+	}
+	return -1;
+}
+
+int
+rte_process_info_register(const char *cmd, process_info_cb fn)
+{
+	if (num_callbacks >= PINFO_MAX_CALLBACKS)
+		return -ENOENT;
+
+	if (cmd == NULL || cmd[0] != '/' || fn == NULL)
+		return -EINVAL;
+
+	rte_spinlock_lock(&callback_sl);
+
+	/* Search to see if the command exists already */
+	if (find_command(cmd) < 0) {
+		strlcpy(callbacks[num_callbacks].cmd, cmd, MAX_CMD_LEN);
+		callbacks[num_callbacks++].fn = fn;
+	}
+
+	rte_spinlock_unlock(&callback_sl);
+
+	return 0;
+}
+
+static int
+list_cmd(struct pinfo_client *c)
+{
+	int i;
+
+	rte_process_info_append(c, "\"cmds\": [");
+	for (i = 0; i < num_callbacks; i++)
+		rte_process_info_append(c, "\"%s\"%s",
+			callbacks[i].cmd, ((i + 1) < num_callbacks)? "," : "");
+	rte_process_info_append(c, "]");
+
+	return 0;
+}
+
+static int
+info_cmd(struct pinfo_client *c)
+{
+	rte_process_info_append(c, "\"version\": \"%s\"", rte_version());
+	rte_process_info_append(c, ",\"maxbuffer\": %d", PINFO_MAX_BUF_LEN);
+
+	return 0;
+}
+
+static int
+invalid_cmd(struct pinfo_client *c)
+{
+	if (c->params)
+		rte_process_info_append(c, "\"error\": \"invalid cmd (%s,%s)\"",
+			c->cmd, c->params);
+	else
+		rte_process_info_append(c, "\"error\": \"invalid cmd (%s)\"",
+			c->cmd);
+
+	return 0;
+}
+
+static void
+perform_command(process_info_cb fn, struct pinfo_client *c)
+{
+	rte_process_info_append(c, "{");
+
+	int ret = fn(c);
+
+	if (ret < 0) {
+		rte_process_info_append(c, "}");
+		if (write(c->s, c->buffer, c->used) < 0)
+			perror("Error writing to socket");
+		return;
+	}
+	rte_process_info_append(c, "}");
+	if (write(c->s, c->buffer, c->used) < 0)
+		perror("Error writing to socket");
+
+	c->buffer[0] = '\0';
+	c->used = 0;
+}
+
+static void *
+client_handler(void *sock_id)
+{
+	int s = (int)(uintptr_t)sock_id;
+	struct pinfo_client client, *c = &client;
+
+	/* Make sure the client structure is sane */
+	memset(c, 0, sizeof(struct pinfo_client));
+
+	/* allocate and zero the command buffer */
+	c->cbuf = malloc(MAX_CMD_LEN);
+	if (c->cbuf == NULL)
+		return NULL;
+	memset(c->cbuf, 0, MAX_CMD_LEN);
+
+	client.s = s;
+
+	int bytes;
+
+	for(;;) {
+		bytes = read(s, client.cbuf, MAX_CMD_LEN);
+		if (bytes <= 0)
+			break;
+
+		if (*c->cbuf != '/') {
+			perform_command(invalid_cmd, c);
+			continue;
+		}
+
+		/* receive data is not null terminated */
+		c->cbuf[bytes] = '\0';
+
+		c->cmd = strtok_r(c->cbuf, ",", &c->ptr);
+		c->params = strtok_r(NULL, ",", &c->ptr);
+		int i;
+
+		rte_spinlock_lock(&callback_sl);
+		i = find_command(c->cmd);
+		if (i >= 0) {
+			process_info_cb fn = callbacks[i].fn;
+			rte_spinlock_unlock(&callback_sl);
+			perform_command(fn, c);
+		} else {
+			rte_spinlock_unlock(&callback_sl);
+			perform_command(invalid_cmd, c);
+		}
+	}
+	close(s);
+
+	free(c->buffer);
+	free(c->cbuf);
+	return NULL;
+}
+
+static void *
+socket_listener(void *unused __rte_unused)
+{
+	while (1) {
+		pthread_t th;
+		int s = accept(sock, NULL, NULL);
+		if (s < 0) {
+			snprintf(process_info_log_error, sizeof(process_info_log_error),
+					"Error with accept, process_info thread quitting\n");
+			return NULL;
+		}
+		pthread_create(&th, NULL, client_handler, (void *)(uintptr_t)s);
+		pthread_detach(th);
+	}
+	return NULL;
+}
+
+static inline char *
+get_socket_path(const char *runtime_dir)
+{
+	static char path[PATH_MAX];
+
+	if (strlen(runtime_dir) == 0)
+		snprintf(path, sizeof(path), "/tmp/dpdk_process_info.%d",
+				getpid());
+	else
+		snprintf(path, sizeof(path), "%s/process_info.%d",
+				runtime_dir, getpid());
+	return path;
+}
+
+static void
+unlink_socket(void)
+{
+	if (sun.sun_path[0])
+		unlink(sun.sun_path);
+}
+
+int
+rte_process_info_init(const char *runtime_dir, const char **err_str)
+{
+	pthread_t t;
+
+	sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
+	if (sock < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error with socket creation, %s",
+				strerror(errno));
+		*err_str = process_info_log_error;
+		return -1;
+	}
+
+	sun.sun_family = AF_UNIX;
+	if (strlcpy(sun.sun_path, get_socket_path(runtime_dir),
+			sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error with socket binding, path too long");
+		goto error;
+	}
+	if (bind(sock, (void *)&sun, sizeof(sun)) < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error binding socket: %s",
+				strerror(errno));
+		sun.sun_path[0] = 0;
+		goto error;
+	}
+
+	if (listen(sock, 1) < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error calling listen for socket: %s",
+				strerror(errno));
+		goto error;
+	}
+
+	pthread_create(&t, NULL, socket_listener, NULL);
+	atexit(unlink_socket);
+
+	return 0;
+
+error:
+	close(sock);
+	unlink_socket();
+	sock = -1;
+	*err_str = process_info_log_error;
+	return -1;
+}
+
+int
+rte_process_info_append(struct pinfo_client *c, const char *format, ...)
+{
+	va_list ap;
+	char str[PATH_MAX];
+	int ret, nbytes;
+
+	va_start(ap, format);
+	ret = vsnprintf(str, sizeof(str), format, ap);
+	va_end(ap);
+
+	/* First time just allocate some memory to use for buffer */
+	if (c->buffer == NULL) {
+		c->buffer = malloc(4 * PINFO_EXTRA_SPACE);
+		if (c->buffer == NULL) {
+			printf("Buffer is NULL\n");
+			return -1;
+		}
+		memset(c->buffer, 0, (4 * PINFO_EXTRA_SPACE));
+		c->buf_len = (4 * PINFO_EXTRA_SPACE);
+		c->used = 0;
+	}
+
+	nbytes = (ret + c->used) + PINFO_EXTRA_SPACE;
+
+	/* Increase size of buffer if required */
+	if (nbytes > c->buf_len) {
+
+		/* Make sure the max length is capped to a max size */
+		if (nbytes > PINFO_MAX_BUF_LEN)
+			return -1;
+
+		/* expand the buffer space */
+		char *p = realloc(c->buffer, nbytes);
+
+		if (p == NULL)
+			return -1;
+
+		c->buffer = p;
+		c->buf_len = nbytes;
+	}
+
+	/* Add the new string data to the buffer */
+	c->used = strlcat(c->buffer, str, c->buf_len);
+
+	return 0;
+}
diff --git a/lib/librte_process_info/rte_process_info.h b/lib/librte_process_info/rte_process_info.h
new file mode 100644
index 000000000..9924af8cf
--- /dev/null
+++ b/lib/librte_process_info/rte_process_info.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018 Intel Corporation
+ */
+
+#include <stdint.h>
+
+#ifndef _RTE_TELEMETRY_H_
+#define _RTE_TELEMETRY_H_
+
+#define PINFO_MAX_CALLBACKS 64
+
+#define PINFO_EXTRA_SPACE	64
+#define PINFO_MAX_BUF_LEN	(16 * 1024)
+
+struct pinfo_client {
+	char *cbuf;
+	char *buffer;
+	char *ptr;
+	const char *cmd;
+	const char *params;
+	int buf_len;
+	int used;
+	int s;
+};
+
+/* callback returns json data in buffer, up to buf_len long.
+ * returns length of buffer used on success, negative on error.
+ */
+typedef int (*process_info_cb)(struct pinfo_client *c);
+
+__rte_experimental
+int rte_process_info_register(const char *cmd, process_info_cb fn);
+
+__rte_experimental
+int rte_process_info_init(const char *runtime_dir, const char **err_str);
+
+__rte_experimental
+int rte_process_info_append(struct pinfo_client *client, const char *format, ...);
+
+#endif
diff --git a/lib/librte_process_info/rte_process_info_version.map b/lib/librte_process_info/rte_process_info_version.map
new file mode 100644
index 000000000..466751a55
--- /dev/null
+++ b/lib/librte_process_info/rte_process_info_version.map
@@ -0,0 +1,7 @@
+EXPERIMENTAL {
+	global:
+		rte_process_info_init;
+		rte_process_info_register;
+		rte_process_info_append;
+	local: *;
+};
diff --git a/lib/librte_rawdev/Makefile b/lib/librte_rawdev/Makefile
index 7dd1197dc..749ad619c 100644
--- a/lib/librte_rawdev/Makefile
+++ b/lib/librte_rawdev/Makefile
@@ -9,7 +9,9 @@ LIB = librte_rawdev.a
 # build flags
 CFLAGS += -O3
 CFLAGS += $(WERROR_FLAGS)
-LDLIBS += -lrte_eal
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
+CFLAGS += -DALLOW_EXPERIMENTAL_API
+LDLIBS += -lrte_eal -lrte_process_info

 # library source files
 SRCS-y += rte_rawdev.c
diff --git a/lib/librte_rawdev/meson.build b/lib/librte_rawdev/meson.build
index a20fbdc04..e8e45e426 100644
--- a/lib/librte_rawdev/meson.build
+++ b/lib/librte_rawdev/meson.build
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: BSD-3-Clause
 # Copyright(c) 2018 Intel Corporation

+allow_experimental_apis = true
+
 sources = files('rte_rawdev.c')
 headers = files('rte_rawdev.h', 'rte_rawdev_pmd.h')
diff --git a/lib/librte_rawdev/rte_rawdev.c b/lib/librte_rawdev/rte_rawdev.c
index b6f1e1c77..a17ca3b53 100644
--- a/lib/librte_rawdev/rte_rawdev.c
+++ b/lib/librte_rawdev/rte_rawdev.c
@@ -29,6 +29,7 @@
 #include <rte_common.h>
 #include <rte_malloc.h>
 #include <rte_errno.h>
+#include <rte_process_info.h>

 #include "rte_rawdev.h"
 #include "rte_rawdev_pmd.h"
@@ -544,9 +545,97 @@ rte_rawdev_pmd_release(struct rte_rawdev *rawdev)
 	return 0;
 }

+static int
+handle_dev_list(struct pinfo_client *c)
+{
+	int used = 0;
+	int i;
+
+	rte_process_info_append(c, "\"ids\": [");
+	for (i = 0; i < rawdev_globals.nb_devs; i++)
+		if (rte_rawdevices[i].attached == RTE_RAWDEV_ATTACHED)
+			rte_process_info_append(c, "%d%s",
+				rte_rawdevices[i].dev_id, ((i + 1) < rawdev_globals.nb_devs)? "," : "");
+
+	rte_process_info_append(c, "]");
+	return used;
+}
+
+static int
+handle_dev_xstats(struct pinfo_client *c)
+{
+	uint64_t *rawdev_xstats;
+	struct rte_rawdev_xstats_name *xstat_names;
+	int dev_id, num_xstats, i, ret;
+	int used = 0;
+	unsigned int *ids;
+
+	used = 0;
+	rawdev_xstats = NULL;
+
+	if (c->params == NULL)
+		goto error;
+
+	dev_id = atoi(c->params);
+
+	if (!rte_rawdev_pmd_is_valid_dev(dev_id))
+		goto error;
+
+	if (rte_process_info_append(c, "\"%d\":", dev_id) < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "{") < 0)
+		goto error;
+
+	num_xstats = xstats_get_count(dev_id);
+	if (num_xstats < 0)
+		goto error;
+
+	/* use one malloc for names, stats and ids */
+	rawdev_xstats = malloc((sizeof(uint64_t) +
+			sizeof(struct rte_rawdev_xstats_name) +
+			sizeof(unsigned int)) * num_xstats);
+	if (rawdev_xstats == NULL)
+		goto error;
+	xstat_names = (void *)&rawdev_xstats[num_xstats];
+	ids = (void *)&xstat_names[num_xstats];
+
+	ret = rte_rawdev_xstats_names_get(dev_id, xstat_names, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++)
+		ids[i] = i;
+
+	ret = rte_rawdev_xstats_get(dev_id, ids, rawdev_xstats, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++) {
+		if (rte_process_info_append(c, "\"%s\":%"PRIu64"%s",
+				xstat_names[i].name, rawdev_xstats[i],
+				((i + 1) < num_xstats)? "," : "") < 0)
+			goto error;
+	}
+
+	if (rte_process_info_append(c, "}") < 0)
+		goto error;
+
+	free(rawdev_xstats);
+	rawdev_xstats = NULL;
+
+	return used;
+
+error:
+	free(rawdev_xstats);
+	return -1;
+}
+
 RTE_INIT(librawdev_init_log)
 {
 	librawdev_logtype = rte_log_register("lib.rawdev");
 	if (librawdev_logtype >= 0)
 		rte_log_set_level(librawdev_logtype, RTE_LOG_INFO);
+	rte_process_info_register("/rawdev:list", handle_dev_list);
+	rte_process_info_register("/rawdev:xstats", handle_dev_xstats);
 }
diff --git a/lib/meson.build b/lib/meson.build
index 0af3efab2..cc44e5bcb 100644
--- a/lib/meson.build
+++ b/lib/meson.build
@@ -10,6 +10,7 @@
 # core libs which are widely reused, so their deps are kept to a minimum.
 libraries = [
 	'kvargs', # eal depends on kvargs
+	'process_info', # basic info querying capability about dpdk processes
 	'eal', # everything depends on eal
 	'ring', 'mempool', 'mbuf', 'net', 'meter', 'ethdev', 'pci', # core
 	'cmdline',
@@ -30,7 +31,7 @@ libraries = [
 	# add pkt framework libs which use other libs from above
 	'port', 'table', 'pipeline',
 	# flow_classify lib depends on pkt framework table lib
-	'flow_classify', 'bpf', 'telemetry']
+	'flow_classify', 'bpf']

 if is_windows
 	libraries = ['kvargs','eal'] # only supported libraries for windows
diff --git a/meson.build b/meson.build
index b7ae9c8d9..1db1c6193 100644
--- a/meson.build
+++ b/meson.build
@@ -18,6 +18,7 @@ dpdk_libraries = []
 dpdk_static_libraries = []
 dpdk_driver_classes = []
 dpdk_drivers = []
+dpdk_extra_cflags = []
 dpdk_extra_ldflags = []
 dpdk_app_link_libraries = []
 dpdk_libs_disabled = []
diff --git a/mk/rte.app.mk b/mk/rte.app.mk
index 15acf95db..d65d545eb 100644
--- a/mk/rte.app.mk
+++ b/mk/rte.app.mk
@@ -98,6 +98,7 @@ _LDLIBS-$(CONFIG_RTE_LIBRTE_CMDLINE)        += -lrte_cmdline
 _LDLIBS-$(CONFIG_RTE_LIBRTE_REORDER)        += -lrte_reorder
 _LDLIBS-$(CONFIG_RTE_LIBRTE_SCHED)          += -lrte_sched
 _LDLIBS-$(CONFIG_RTE_LIBRTE_RCU)            += -lrte_rcu
+_LDLIBS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO)   += -lrte_process_info

 ifeq ($(CONFIG_RTE_EXEC_ENV_LINUX),y)
 _LDLIBS-$(CONFIG_RTE_LIBRTE_KNI)            += -lrte_kni
diff --git a/usertools/test_pinfo.py b/usertools/test_pinfo.py
new file mode 100755
index 000000000..3e7cd3b0d
--- /dev/null
+++ b/usertools/test_pinfo.py
@@ -0,0 +1,22 @@
+#! /usr/bin/python3
+
+import socket
+import os
+import sys
+import time
+import glob
+
+fd = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
+for f in glob.glob('/var/run/dpdk/rte/process_info.*'):
+    print("Connecting to " + f)
+    try:
+        fd.connect(f)
+    except OSError:
+        continue
+    text = input('--> ')
+    while (text != "quit"):
+        fd.send(text.encode())
+        d = fd.recv(64*1024)
+        print(d.decode())
+        text = input('--> ')
+    fd.close()
--
2.20.1
