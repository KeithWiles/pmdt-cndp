From 7875da3c2bc1ca95ee4aa90343efc50204c7d329 Mon Sep 17 00:00:00 2001
From: Xiaoban WU <xiaoban_wu@student.uml.edu>
Date: Fri, 7 Feb 2020 12:51:37 -0500
Subject: [PATCH] Updating to include features to enable performance monitoring
 for all DPDK-based applications

---
 config/common_linuxapp                             |   1 +
 drivers/net/meson.build                            |   2 +-
 lib/Makefile                                       |   2 +
 lib/librte_eal/linuxapp/eal/Makefile               |   1 +
 lib/librte_eal/linuxapp/eal/eal.c                  |  60 ++++
 lib/librte_eal/meson.build                         |   2 +-
 lib/librte_ethdev/Makefile                         |   3 +-
 lib/librte_ethdev/rte_ethdev.c                     | 186 ++++++++++++
 lib/librte_net/rte_ether.h                         |   2 +-
 lib/librte_process_info/Makefile                   |  21 ++
 lib/librte_process_info/meson.build                |   9 +
 lib/librte_process_info/process_info.c             | 338 +++++++++++++++++++++
 lib/librte_process_info/rte_process_info.h         |  40 +++
 .../rte_process_info_version.map                   |   7 +
 lib/librte_rawdev/Makefile                         |   4 +-
 lib/librte_rawdev/meson.build                      |   2 +
 lib/librte_rawdev/rte_rawdev.c                     |  89 ++++++
 lib/meson.build                                    |   3 +-
 meson.build                                        |   1 +
 mk/rte.app.mk                                      |   1 +
 usertools/test_pinfo.py                            |  22 ++
 21 files changed, 790 insertions(+), 6 deletions(-)
 create mode 100644 lib/librte_process_info/Makefile
 create mode 100644 lib/librte_process_info/meson.build
 create mode 100644 lib/librte_process_info/process_info.c
 create mode 100644 lib/librte_process_info/rte_process_info.h
 create mode 100644 lib/librte_process_info/rte_process_info_version.map
 create mode 100644 usertools/test_pinfo.py

diff --git a/config/common_linuxapp b/config/common_linuxapp
index 6c1c8d0..0c53c8e 100644
--- a/config/common_linuxapp
+++ b/config/common_linuxapp
@@ -26,6 +26,7 @@ CONFIG_RTE_LIBRTE_NFP_PMD=y
 CONFIG_RTE_LIBRTE_POWER=y
 CONFIG_RTE_VIRTIO_USER=y
 CONFIG_RTE_PROC_INFO=y
+CONFIG_RTE_LIBRTE_PROCESS_INFO=y
 
 CONFIG_RTE_LIBRTE_VMBUS=y
 CONFIG_RTE_LIBRTE_NETVSC_PMD=y
diff --git a/drivers/net/meson.build b/drivers/net/meson.build
index 980eec2..8ac2bde 100644
--- a/drivers/net/meson.build
+++ b/drivers/net/meson.build
@@ -27,7 +27,7 @@ drivers = ['af_packet',
 	'mvpp2',
 	'netvsc',
 	'nfp',
-	'null', 'octeontx', 'pcap', 'qede', 'ring',
+	'null', 'octeontx', 'pcap', 'pfe', 'qede', 'ring',
 	'sfc',
 	'softnic',
 	'szedata2',
diff --git a/lib/Makefile b/lib/Makefile
index b7370ef..7c8e302 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -18,6 +18,8 @@ DIRS-$(CONFIG_RTE_LIBRTE_MBUF) += librte_mbuf
 DEPDIRS-librte_mbuf := librte_eal librte_mempool
 DIRS-$(CONFIG_RTE_LIBRTE_TIMER) += librte_timer
 DEPDIRS-librte_timer := librte_eal
+DIRS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO) += librte_process_info
+DEPDIRS-librte_process_info := librte_eal
 DIRS-$(CONFIG_RTE_LIBRTE_CFGFILE) += librte_cfgfile
 DIRS-$(CONFIG_RTE_LIBRTE_CMDLINE) += librte_cmdline
 DEPDIRS-librte_cmdline := librte_eal
diff --git a/lib/librte_eal/linuxapp/eal/Makefile b/lib/librte_eal/linuxapp/eal/Makefile
index 51deb57..576d6cd 100644
--- a/lib/librte_eal/linuxapp/eal/Makefile
+++ b/lib/librte_eal/linuxapp/eal/Makefile
@@ -18,6 +18,7 @@ CFLAGS += -DALLOW_EXPERIMENTAL_API
 CFLAGS += -I$(SRCDIR)/include
 CFLAGS += -I$(RTE_SDK)/lib/librte_eal/common
 CFLAGS += -I$(RTE_SDK)/lib/librte_eal/common/include
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
 CFLAGS += $(WERROR_FLAGS) -O3
 
 LDLIBS += -ldl
diff --git a/lib/librte_eal/linuxapp/eal/eal.c b/lib/librte_eal/linuxapp/eal/eal.c
index f453337..9194a08 100644
--- a/lib/librte_eal/linuxapp/eal/eal.c
+++ b/lib/librte_eal/linuxapp/eal/eal.c
@@ -51,6 +51,7 @@
 #include <malloc_heap.h>
 #include <rte_vfio.h>
 #include <rte_option.h>
+#include <rte_process_info.h>
 
 #include "eal_private.h"
 #include "eal_thread.h"
@@ -101,6 +102,38 @@ static char runtime_dir[PATH_MAX];
 
 static const char *default_runtime_dir = "/var/run";
 
+static char **eal_args, **app_args;
+static int eal_argc;
+
+/* callback handler for process_info library to report out EAL flags */
+static int
+handle_eal_params_request(struct pinfo_client *c)
+{
+	char **p;
+	int i;
+
+	if (eal_args == NULL || eal_args[0] == NULL)
+		return -1;
+
+	rte_process_info_append(c, "\"ealargs\": [");
+	for (i = 0, p = eal_args; i < eal_argc; i++, p++) {
+		if (p == app_args)
+			break;
+		rte_process_info_append(c, "\"%s\"%s",
+				*p, ((p + 1) != app_args)? "," : "");
+	}
+	if (app_args != NULL) {
+		rte_process_info_append(c, "],\"appargs\": [");
+		for (p = app_args; i < eal_argc && *p != NULL; i++, p++) {
+			rte_process_info_append(c, "\"%s\"%s",
+					*p, (p[1] != NULL)? "," : "");
+		}
+	}
+	rte_process_info_append(c, "]");
+
+	return c->used;
+}
+
 int
 eal_create_runtime_dir(void)
 {
@@ -964,6 +997,27 @@ rte_eal_init(int argc, char **argv)
 
 	eal_reset_internal_config(&internal_config);
 
+	/* clone argv to report out later */
+	eal_argc = argc;
+	eal_args = calloc(argc + 1, sizeof(*eal_args));
+	app_args = NULL;
+	if (eal_args != NULL) {
+		char **p = eal_args;
+
+		for (i = 0; i < argc; i++) {
+			if (strcmp(argv[i], "--") == 0)
+				app_args = p;
+			else
+				*p++ = strdup(argv[i]);
+		}
+		*p = NULL; /* always finish with NULL */
+		if (app_args == NULL)
+			app_args = p;
+
+		rte_process_info_register("/eal:params",
+				handle_eal_params_request);
+	}
+
 	/* set log level as early as possible */
 	eal_log_level_parse(argc, argv);
 
@@ -1224,6 +1278,12 @@ rte_eal_init(int argc, char **argv)
 		return -1;
 	}
 
+	const char *error_str;
+	if (rte_process_info_init(rte_eal_get_runtime_dir(), &error_str) != 0) {
+		rte_eal_init_alert(error_str);
+		return -1;
+	}
+	
 	rte_eal_mcfg_complete();
 
 	/* Call each registered callback, if enabled */
diff --git a/lib/librte_eal/meson.build b/lib/librte_eal/meson.build
index a18f3a8..d1a4a94 100644
--- a/lib/librte_eal/meson.build
+++ b/lib/librte_eal/meson.build
@@ -24,7 +24,7 @@ endif
 version = 9  # the version of the EAL API
 allow_experimental_apis = true
 deps += 'compat'
-deps += 'kvargs'
+deps += ['kvargs', 'process_info']
 sources = common_sources + env_sources
 objs = common_objs + env_objs
 headers = common_headers + env_headers
diff --git a/lib/librte_ethdev/Makefile b/lib/librte_ethdev/Makefile
index 3e27ae4..846bc1e 100644
--- a/lib/librte_ethdev/Makefile
+++ b/lib/librte_ethdev/Makefile
@@ -11,8 +11,9 @@ LIB = librte_ethdev.a
 CFLAGS += -DALLOW_EXPERIMENTAL_API
 CFLAGS += -O3
 CFLAGS += $(WERROR_FLAGS)
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
 LDLIBS += -lrte_net -lrte_eal -lrte_mempool -lrte_ring
-LDLIBS += -lrte_mbuf -lrte_kvargs -lrte_cmdline
+LDLIBS += -lrte_mbuf -lrte_kvargs -lrte_cmdline -lrte_process_info
 
 EXPORT_MAP := rte_ethdev_version.map
 
diff --git a/lib/librte_ethdev/rte_ethdev.c b/lib/librte_ethdev/rte_ethdev.c
index 3c75d3c..7e05592 100644
--- a/lib/librte_ethdev/rte_ethdev.c
+++ b/lib/librte_ethdev/rte_ethdev.c
@@ -37,6 +37,7 @@
 #include <rte_string_fns.h>
 #include <rte_kvargs.h>
 #include <rte_class.h>
+#include <rte_process_info.h>
 
 #include "rte_ether.h"
 #include "rte_ethdev.h"
@@ -4476,9 +4477,194 @@ rte_eth_devargs_parse(const char *dargs, struct rte_eth_devargs *eth_da)
 	return result;
 }
 
+static int
+handle_port_list(struct pinfo_client *c)
+{
+	struct rte_eth_link link;
+	int used = 0;
+	int port_id;
+
+	rte_process_info_append(c, "\"ports\": [");
+	RTE_ETH_FOREACH_DEV(port_id) {
+		rte_eth_link_get_nowait(port_id, &link);
+		rte_process_info_append(c, "{\"port\": %d, \"duplex\": \"%s\", \"state\": \"%s\", \"rate\": %d }%s",
+			port_id,
+			link.link_duplex == ETH_LINK_FULL_DUPLEX? "Full" : "Half",
+			link.link_status == ETH_LINK_UP? "UP" : "DOWN",
+			link.link_speed,
+			((port_id + 1) < rte_eth_dev_count_avail())? "," : "");
+	}
+
+	rte_process_info_append(c, "], \"avail\": %d, \"total\": %d",
+		rte_eth_dev_count_avail(), rte_eth_dev_count_total());
+	return used;
+}
+
+static int
+handle_port_stats(struct pinfo_client *c)
+{
+	struct rte_eth_stats eth_stats;
+	int port_id;
+	int i;
+
+	memset(&eth_stats, 0, sizeof(struct rte_eth_stats));
+
+	if (c->params == NULL)
+		goto error;
+
+	port_id = atoi(c->params);
+
+	if (!rte_eth_dev_is_valid_port(port_id))
+		goto error;
+
+	if (rte_eth_stats_get(port_id, &eth_stats))
+		goto error;
+
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",", "portid", port_id) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ipackets", eth_stats.ipackets) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"opackets", eth_stats.opackets) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ibytes", eth_stats.ibytes) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"obytes", eth_stats.obytes) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"imissed", eth_stats.imissed) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"ierrors", eth_stats.ierrors) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"oerrors", eth_stats.oerrors) < 0)
+		goto error;
+	if (rte_process_info_append(c, "\"%s\":%"PRIu64",",
+			"rx_nombuf", eth_stats.rx_nombuf) < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_ipackets\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_ipackets[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_opackets\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_opackets[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_ibytes\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_ibytes[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_obytes\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_obytes[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "],") < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "\"q_errors\": [") < 0)
+		goto error;
+	for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+		if (rte_process_info_append(c, "%"PRIu64"%s", eth_stats.q_errors[i],
+				((i + 1) < RTE_ETHDEV_QUEUE_STAT_CNTRS)? "," : "") < 0)
+			goto error;
+	}
+	if (rte_process_info_append(c, "]") < 0)
+		goto error;
+
+	return 0;
+
+error:
+	return -1;
+}
+
+static int
+handle_port_xstats(struct pinfo_client *c)
+{
+	struct rte_eth_xstat *eth_xstats;
+	struct rte_eth_xstat_name *xstat_names;
+	int port_id, num_xstats;
+	int i, ret;
+	int used;
+
+	used = 0;
+	eth_xstats = NULL;
+
+	if (c->params == NULL)
+		goto error;
+
+	port_id = atoi(c->params);
+
+	if (!rte_eth_dev_is_valid_port(port_id))
+		goto error;
+
+	num_xstats = rte_eth_xstats_get(port_id, NULL, 0);
+	if (num_xstats < 0)
+		goto error;
+
+	/* use one malloc for both names and stats */
+	eth_xstats = malloc((sizeof(struct rte_eth_xstat) +
+			sizeof(struct rte_eth_xstat_name)) * num_xstats);
+	if (eth_xstats == NULL)
+		goto error;
+	xstat_names = (void *)&eth_xstats[num_xstats];
+
+	ret = rte_eth_xstats_get_names(port_id, xstat_names, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	ret = rte_eth_xstats_get(port_id, eth_xstats, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++) {
+		if (rte_process_info_append(c, "\"%s\":%"PRIu64"%s",
+				xstat_names[i].name, eth_xstats[i].value,
+				((i + 1) < num_xstats)? "," : "") < 0)
+			goto error;
+	}
+
+	free(eth_xstats);
+	eth_xstats = NULL;
+
+	return used;
+
+error:
+	free(eth_xstats);
+	return -1;
+}
+
 RTE_INIT(ethdev_init_log)
 {
 	rte_eth_dev_logtype = rte_log_register("lib.ethdev");
 	if (rte_eth_dev_logtype >= 0)
 		rte_log_set_level(rte_eth_dev_logtype, RTE_LOG_INFO);
+	rte_process_info_register("/ethdev:list", handle_port_list);
+	rte_process_info_register("/ethdev:stats", handle_port_stats);
+	rte_process_info_register("/ethdev:xstats", handle_port_xstats);
 }
diff --git a/lib/librte_net/rte_ether.h b/lib/librte_net/rte_ether.h
index 71299d9..138b74d 100644
--- a/lib/librte_net/rte_ether.h
+++ b/lib/librte_net/rte_ether.h
@@ -56,7 +56,7 @@ extern "C" {
  */
 struct ether_addr {
 	uint8_t addr_bytes[ETHER_ADDR_LEN]; /**< Addr bytes in tx order */
-} __attribute__((__packed__));
+};
 
 #define ETHER_LOCAL_ADMIN_ADDR 0x02 /**< Locally assigned Eth. address. */
 #define ETHER_GROUP_ADDR       0x01 /**< Multicast or broadcast Eth. address. */
diff --git a/lib/librte_process_info/Makefile b/lib/librte_process_info/Makefile
new file mode 100644
index 0000000..9ade85a
--- /dev/null
+++ b/lib/librte_process_info/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2010-2014 Intel Corporation
+
+include $(RTE_SDK)/mk/rte.vars.mk
+
+# library name
+LIB = librte_process_info.a
+
+CFLAGS += $(WERROR_FLAGS) -I$(SRCDIR) -O3
+CFLAGS += -DALLOW_EXPERIMENTAL_API
+LDLIBS += -lrte_eal
+
+EXPORT_MAP := rte_process_info_version.map
+
+# all source are stored in SRCS-y
+SRCS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO) := process_info.c
+
+# install includes
+SYMLINK-$(CONFIG_RTE_LIBRTE_PROCESS_INFO)-include := rte_process_info.h
+
+include $(RTE_SDK)/mk/rte.lib.mk
diff --git a/lib/librte_process_info/meson.build b/lib/librte_process_info/meson.build
new file mode 100644
index 0000000..ac4e333
--- /dev/null
+++ b/lib/librte_process_info/meson.build
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2018 Intel Corporation
+
+includes = [global_inc]
+includes += include_directories('../librte_eal/common/include/arch/' + arch_subdir)
+
+allow_experimental_apis = true
+sources = files('process_info.c')
+headers = files('rte_process_info.h')
diff --git a/lib/librte_process_info/process_info.c b/lib/librte_process_info/process_info.c
new file mode 100644
index 0000000..9240b4b
--- /dev/null
+++ b/lib/librte_process_info/process_info.c
@@ -0,0 +1,338 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019 Intel Corporation
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <dlfcn.h>
+
+#include <rte_version.h>
+#include <rte_string_fns.h>
+#include <rte_common.h>
+#include <rte_spinlock.h>
+
+#include "rte_process_info.h"
+
+
+static int list_cmd(struct pinfo_client *c);
+static int info_cmd(struct pinfo_client *c);
+
+#define MAX_CMD_LEN	56
+
+struct cmd_callback {
+	char cmd[MAX_CMD_LEN];
+	process_info_cb fn;
+};
+
+static int sock = -1;
+static struct sockaddr_un sun;
+static char process_info_log_error[1024];
+static struct cmd_callback callbacks[PINFO_MAX_CALLBACKS + 1] = {
+		{ .cmd = "/", .fn = list_cmd },
+		{ .cmd = "/dpdk:info", .fn = info_cmd },
+};
+static int num_callbacks = 2;
+static rte_spinlock_t callback_sl = RTE_SPINLOCK_INITIALIZER;
+
+/* we won't link against libbsd, so just always use DPDKs-specific version */
+#ifndef strlcpy
+#define strlcpy rte_strlcpy
+#endif
+#ifndef strlcat
+#define strlcat rte_strlcat
+#endif
+
+/*
+ * find a command in the list of callbacks
+ *
+ * @params cmd
+ *    The command string to search in the callback list case-insenstive
+ * @return
+ *    returns the index of the matching command of -1 if not found
+ */
+static int
+find_command(const char *cmd)
+{
+	int	i = -1;
+
+	if (cmd && cmd[0] == '/') {
+		for(i = 0; i < num_callbacks; i++) {
+			if (strcasecmp(cmd, callbacks[i].cmd) == 0)
+				return i;
+		}
+	}
+	return -1;
+}
+
+int
+rte_process_info_register(const char *cmd, process_info_cb fn)
+{
+	if (num_callbacks >= PINFO_MAX_CALLBACKS)
+		return -ENOENT;
+
+	if (cmd == NULL || cmd[0] != '/' || fn == NULL)
+		return -EINVAL;
+
+	rte_spinlock_lock(&callback_sl);
+
+	/* Search to see if the command exists already */
+	if (find_command(cmd) < 0) {
+		strlcpy(callbacks[num_callbacks].cmd, cmd, MAX_CMD_LEN);
+		callbacks[num_callbacks++].fn = fn;
+	}
+
+	rte_spinlock_unlock(&callback_sl);
+
+	return 0;
+}
+
+static int
+list_cmd(struct pinfo_client *c)
+{
+	int i;
+
+	rte_process_info_append(c, "\"cmds\": [");
+	for (i = 0; i < num_callbacks; i++)
+		rte_process_info_append(c, "\"%s\"%s",
+			callbacks[i].cmd, ((i + 1) < num_callbacks)? "," : "");
+	rte_process_info_append(c, "]");
+
+	return 0;
+}
+
+static int
+info_cmd(struct pinfo_client *c)
+{
+	rte_process_info_append(c, "\"version\": \"%s\"", rte_version());
+	rte_process_info_append(c, ",\"maxbuffer\": %d", PINFO_MAX_BUF_LEN);
+
+	return 0;
+}
+
+static int
+invalid_cmd(struct pinfo_client *c)
+{
+	if (c->params)
+		rte_process_info_append(c, "\"error\": \"invalid cmd (%s,%s)\"",
+			c->cmd, c->params);
+	else
+		rte_process_info_append(c, "\"error\": \"invalid cmd (%s)\"",
+			c->cmd);
+
+	return 0;
+}
+
+static void
+perform_command(process_info_cb fn, struct pinfo_client *c)
+{
+	rte_process_info_append(c, "{");
+
+	int ret = fn(c);
+
+	if (ret < 0) {
+		rte_process_info_append(c, "}");
+		if (write(c->s, c->buffer, c->used) < 0)
+			perror("Error writing to socket");
+		return;
+	}
+	rte_process_info_append(c, "}");
+	if (write(c->s, c->buffer, c->used) < 0)
+		perror("Error writing to socket");
+
+	c->buffer[0] = '\0';
+	c->used = 0;
+}
+
+static void *
+client_handler(void *sock_id)
+{
+	int s = (int)(uintptr_t)sock_id;
+	struct pinfo_client client, *c = &client;
+
+	/* Make sure the client structure is sane */
+	memset(c, 0, sizeof(struct pinfo_client));
+
+	/* allocate and zero the command buffer */
+	c->cbuf = malloc(MAX_CMD_LEN);
+	if (c->cbuf == NULL)
+		return NULL;
+	memset(c->cbuf, 0, MAX_CMD_LEN);
+
+	client.s = s;
+
+	int bytes;
+
+	for(;;) {
+		bytes = read(s, client.cbuf, MAX_CMD_LEN);
+		if (bytes <= 0)
+			break;
+
+		if (*c->cbuf != '/') {
+			perform_command(invalid_cmd, c);
+			continue;
+		}
+
+		/* receive data is not null terminated */
+		c->cbuf[bytes] = '\0';
+
+		c->cmd = strtok_r(c->cbuf, ",", &c->ptr);
+		c->params = strtok_r(NULL, ",", &c->ptr);
+		int i;
+
+		rte_spinlock_lock(&callback_sl);
+		i = find_command(c->cmd);
+		if (i >= 0) {
+			process_info_cb fn = callbacks[i].fn;
+			rte_spinlock_unlock(&callback_sl);
+			perform_command(fn, c);
+		} else {
+			rte_spinlock_unlock(&callback_sl);
+			perform_command(invalid_cmd, c);
+		}
+	}
+	close(s);
+
+	free(c->buffer);
+	free(c->cbuf);
+	return NULL;
+}
+
+static void *
+socket_listener(void *unused __rte_unused)
+{
+	while (1) {
+		pthread_t th;
+		int s = accept(sock, NULL, NULL);
+		if (s < 0) {
+			snprintf(process_info_log_error, sizeof(process_info_log_error),
+					"Error with accept, process_info thread quitting\n");
+			return NULL;
+		}
+		pthread_create(&th, NULL, client_handler, (void *)(uintptr_t)s);
+		pthread_detach(th);
+	}
+	return NULL;
+}
+
+static inline char *
+get_socket_path(const char *runtime_dir)
+{
+	static char path[PATH_MAX];
+
+	if (strlen(runtime_dir) == 0)
+		snprintf(path, sizeof(path), "/tmp/dpdk_process_info.%d",
+				getpid());
+	else
+		snprintf(path, sizeof(path), "%s/process_info.%d",
+				runtime_dir, getpid());
+	return path;
+}
+
+static void
+unlink_socket(void)
+{
+	if (sun.sun_path[0])
+		unlink(sun.sun_path);
+}
+
+int
+rte_process_info_init(const char *runtime_dir, const char **err_str)
+{
+	pthread_t t;
+
+	sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
+	if (sock < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error with socket creation, %s",
+				strerror(errno));
+		*err_str = process_info_log_error;
+		return -1;
+	}
+
+	sun.sun_family = AF_UNIX;
+	if (strlcpy(sun.sun_path, get_socket_path(runtime_dir),
+			sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error with socket binding, path too long");
+		goto error;
+	}
+	if (bind(sock, (void *)&sun, sizeof(sun)) < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error binding socket: %s",
+				strerror(errno));
+		sun.sun_path[0] = 0;
+		goto error;
+	}
+
+	if (listen(sock, 1) < 0) {
+		snprintf(process_info_log_error, sizeof(process_info_log_error),
+				"Error calling listen for socket: %s",
+				strerror(errno));
+		goto error;
+	}
+
+	pthread_create(&t, NULL, socket_listener, NULL);
+	atexit(unlink_socket);
+
+	return 0;
+
+error:
+	close(sock);
+	unlink_socket();
+	sock = -1;
+	*err_str = process_info_log_error;
+	return -1;
+}
+
+int
+rte_process_info_append(struct pinfo_client *c, const char *format, ...)
+{
+	va_list ap;
+	char str[PATH_MAX];
+	int ret, nbytes;
+
+	va_start(ap, format);
+	ret = vsnprintf(str, sizeof(str), format, ap);
+	va_end(ap);
+
+	/* First time just allocate some memory to use for buffer */
+	if (c->buffer == NULL) {
+		c->buffer = malloc(4 * PINFO_EXTRA_SPACE);
+		if (c->buffer == NULL) {
+			printf("Buffer is NULL\n");
+			return -1;
+		}
+		memset(c->buffer, 0, (4 * PINFO_EXTRA_SPACE));
+		c->buf_len = (4 * PINFO_EXTRA_SPACE);
+		c->used = 0;
+	}
+
+	nbytes = (ret + c->used) + PINFO_EXTRA_SPACE;
+
+	/* Increase size of buffer if required */
+	if (nbytes > c->buf_len) {
+
+		/* Make sure the max length is capped to a max size */
+		if (nbytes > PINFO_MAX_BUF_LEN)
+			return -1;
+
+		/* expand the buffer space */
+		char *p = realloc(c->buffer, nbytes);
+
+		if (p == NULL)
+			return -1;
+
+		c->buffer = p;
+		c->buf_len = nbytes;
+	}
+
+	/* Add the new string data to the buffer */
+	c->used = strlcat(c->buffer, str, c->buf_len);
+
+	return 0;
+}
diff --git a/lib/librte_process_info/rte_process_info.h b/lib/librte_process_info/rte_process_info.h
new file mode 100644
index 0000000..9924af8
--- /dev/null
+++ b/lib/librte_process_info/rte_process_info.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018 Intel Corporation
+ */
+
+#include <stdint.h>
+
+#ifndef _RTE_TELEMETRY_H_
+#define _RTE_TELEMETRY_H_
+
+#define PINFO_MAX_CALLBACKS 64
+
+#define PINFO_EXTRA_SPACE	64
+#define PINFO_MAX_BUF_LEN	(16 * 1024)
+
+struct pinfo_client {
+	char *cbuf;
+	char *buffer;
+	char *ptr;
+	const char *cmd;
+	const char *params;
+	int buf_len;
+	int used;
+	int s;
+};
+
+/* callback returns json data in buffer, up to buf_len long.
+ * returns length of buffer used on success, negative on error.
+ */
+typedef int (*process_info_cb)(struct pinfo_client *c);
+
+__rte_experimental
+int rte_process_info_register(const char *cmd, process_info_cb fn);
+
+__rte_experimental
+int rte_process_info_init(const char *runtime_dir, const char **err_str);
+
+__rte_experimental
+int rte_process_info_append(struct pinfo_client *client, const char *format, ...);
+
+#endif
diff --git a/lib/librte_process_info/rte_process_info_version.map b/lib/librte_process_info/rte_process_info_version.map
new file mode 100644
index 0000000..466751a
--- /dev/null
+++ b/lib/librte_process_info/rte_process_info_version.map
@@ -0,0 +1,7 @@
+EXPERIMENTAL {
+	global:
+		rte_process_info_init;
+		rte_process_info_register;
+		rte_process_info_append;
+	local: *;
+};
diff --git a/lib/librte_rawdev/Makefile b/lib/librte_rawdev/Makefile
index addb288..46a2e9a 100644
--- a/lib/librte_rawdev/Makefile
+++ b/lib/librte_rawdev/Makefile
@@ -12,7 +12,9 @@ LIBABIVER := 1
 # build flags
 CFLAGS += -O3
 CFLAGS += $(WERROR_FLAGS)
-LDLIBS += -lrte_eal
+CFLAGS += -I$(RTE_SDK)/lib/librte_process_info
+CFLAGS += -DALLOW_EXPERIMENTAL_API
+LDLIBS += -lrte_eal -lrte_process_info
 
 # library source files
 SRCS-y += rte_rawdev.c
diff --git a/lib/librte_rawdev/meson.build b/lib/librte_rawdev/meson.build
index a20fbdc..e8e45e4 100644
--- a/lib/librte_rawdev/meson.build
+++ b/lib/librte_rawdev/meson.build
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: BSD-3-Clause
 # Copyright(c) 2018 Intel Corporation
 
+allow_experimental_apis = true
+
 sources = files('rte_rawdev.c')
 headers = files('rte_rawdev.h', 'rte_rawdev_pmd.h')
diff --git a/lib/librte_rawdev/rte_rawdev.c b/lib/librte_rawdev/rte_rawdev.c
index 9f1e359..353a037 100644
--- a/lib/librte_rawdev/rte_rawdev.c
+++ b/lib/librte_rawdev/rte_rawdev.c
@@ -28,6 +28,7 @@
 #include <rte_common.h>
 #include <rte_malloc.h>
 #include <rte_errno.h>
+#include <rte_process_info.h>
 
 #include "rte_rawdev.h"
 #include "rte_rawdev_pmd.h"
@@ -542,9 +543,97 @@ rte_rawdev_pmd_release(struct rte_rawdev *rawdev)
 	return 0;
 }
 
+static int
+handle_dev_list(struct pinfo_client *c)
+{
+	int used = 0;
+	int i;
+
+	rte_process_info_append(c, "\"ids\": [");
+	for (i = 0; i < rawdev_globals.nb_devs; i++)
+		if (rte_rawdevices[i].attached == RTE_RAWDEV_ATTACHED)
+			rte_process_info_append(c, "%d%s",
+				rte_rawdevices[i].dev_id, ((i + 1) < rawdev_globals.nb_devs)? "," : "");
+
+	rte_process_info_append(c, "]");
+	return used;
+}
+
+static int
+handle_dev_xstats(struct pinfo_client *c)
+{
+	uint64_t *rawdev_xstats;
+	struct rte_rawdev_xstats_name *xstat_names;
+	int dev_id, num_xstats, i, ret;
+	int used = 0;
+	unsigned int *ids;
+
+	used = 0;
+	rawdev_xstats = NULL;
+
+	if (c->params == NULL)
+		goto error;
+		
+	dev_id = atoi(c->params);
+
+	if (!rte_rawdev_pmd_is_valid_dev(dev_id))
+		goto error;
+
+	if (rte_process_info_append(c, "\"%d\":", dev_id) < 0)
+		goto error;
+
+	if (rte_process_info_append(c, "{") < 0)
+		goto error;
+
+	num_xstats = xstats_get_count(dev_id);
+	if (num_xstats < 0)
+		goto error;
+
+	/* use one malloc for names, stats and ids */
+	rawdev_xstats = malloc((sizeof(uint64_t) +
+			sizeof(struct rte_rawdev_xstats_name) +
+			sizeof(unsigned int)) * num_xstats);
+	if (rawdev_xstats == NULL)
+		goto error;
+	xstat_names = (void *)&rawdev_xstats[num_xstats];
+	ids = (void *)&xstat_names[num_xstats];
+
+	ret = rte_rawdev_xstats_names_get(dev_id, xstat_names, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++)
+		ids[i] = i;
+
+	ret = rte_rawdev_xstats_get(dev_id, ids, rawdev_xstats, num_xstats);
+	if (ret < 0 || ret > num_xstats)
+		goto error;
+
+	for (i = 0; i < num_xstats; i++) {
+		if (rte_process_info_append(c, "\"%s\":%"PRIu64"%s",
+				xstat_names[i].name, rawdev_xstats[i],
+				((i + 1) < num_xstats)? "," : "") < 0)
+			goto error;
+	}
+
+	if (rte_process_info_append(c, "}") < 0)
+		goto error;
+
+	free(rawdev_xstats);
+	rawdev_xstats = NULL;
+
+	return used;
+
+error:
+	free(rawdev_xstats);
+	return -1;
+}
+
 RTE_INIT(librawdev_init_log)
 {
 	librawdev_logtype = rte_log_register("lib.rawdev");
 	if (librawdev_logtype >= 0)
 		rte_log_set_level(librawdev_logtype, RTE_LOG_INFO);
+	rte_process_info_register("/rawdev:list", handle_dev_list);
+	rte_process_info_register("/rawdev:xstats", handle_dev_xstats);
 }
diff --git a/lib/meson.build b/lib/meson.build
index 62b5cdf..626453c 100644
--- a/lib/meson.build
+++ b/lib/meson.build
@@ -11,6 +11,7 @@
 libraries = [ 'compat', # just a header, used for versioning
 	'cmdline', # ethdev depends on cmdline for parsing functions
 	'kvargs', # eal depends on kvargs
+	'process_info', # basic info querying capability about dpdk processes
 	'eal', 'ring', 'mempool', 'mbuf', 'net', 'ethdev', 'pci', # core
 	'metrics', # bitrate/latency stats depends on this
 	'hash',    # efd depends on this
@@ -25,7 +26,7 @@ libraries = [ 'compat', # just a header, used for versioning
 	# add pkt framework libs which use other libs from above
 	'port', 'table', 'pipeline',
 	# flow_classify lib depends on pkt framework table lib
-	'flow_classify', 'bpf', 'telemetry']
+	'flow_classify', 'bpf']
 
 default_cflags = machine_args
 if cc.has_argument('-Wno-format-truncation')
diff --git a/meson.build b/meson.build
index 3b7de01..2e9f07c 100644
--- a/meson.build
+++ b/meson.build
@@ -14,6 +14,7 @@ dpdk_conf = configuration_data()
 dpdk_libraries = []
 dpdk_static_libraries = []
 dpdk_drivers = []
+dpdk_extra_cflags = []
 dpdk_extra_ldflags = []
 dpdk_app_link_libraries = []
 
diff --git a/mk/rte.app.mk b/mk/rte.app.mk
index c539bb9..819e142 100644
--- a/mk/rte.app.mk
+++ b/mk/rte.app.mk
@@ -94,6 +94,7 @@ _LDLIBS-$(CONFIG_RTE_LIBRTE_EAL)            += -lrte_eal
 _LDLIBS-$(CONFIG_RTE_LIBRTE_CMDLINE)        += -lrte_cmdline
 _LDLIBS-$(CONFIG_RTE_LIBRTE_REORDER)        += -lrte_reorder
 _LDLIBS-$(CONFIG_RTE_LIBRTE_SCHED)          += -lrte_sched
+_LDLIBS-$(CONFIG_RTE_LIBRTE_PROCESS_INFO)   += -lrte_process_info
 
 ifeq ($(CONFIG_RTE_EXEC_ENV_LINUXAPP),y)
 _LDLIBS-$(CONFIG_RTE_LIBRTE_KNI)            += -lrte_kni
diff --git a/usertools/test_pinfo.py b/usertools/test_pinfo.py
new file mode 100644
index 0000000..90737b0
--- /dev/null
+++ b/usertools/test_pinfo.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+import socket
+import os
+import sys
+import time
+import glob
+
+fd = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
+for f in glob.glob('/var/run/dpdk/rte/process_info.*'):
+    print("Connecting to " + f)
+    try:
+        fd.connect(f)
+    except OSError:
+        continue
+    text = input('--> ')
+    while (text != "quit"):
+        fd.send(text.encode())
+        d = fd.recv(64*1024)
+        print(d.decode())
+        text = input('--> ')
+    fd.close()
-- 
2.7.4

